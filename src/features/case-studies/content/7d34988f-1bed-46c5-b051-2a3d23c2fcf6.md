# How I Refactored a Rule-Based System Using Classic Design Patterns

Read time: 8 - 10 minutes

---

## Overview

This case study describes how I refactored a workflow automation service (written in Python) that my team and I built at work. This refactor was in response to how it had grown difficult to maintain and scale the system. I applied the Strategy and Factory design patterns to decouple business rules from execution logic, improving maintainability and scalability.

The goal of this case study is to illustrate my ability to design and build scalable, maintainable systems, using a real-life example from my past work experience. This case study will focus on the application of these specific design patterns and the problems they are intended to solve, including a working code example. I'll also include high-level technical specifics around the automation to provide context.

## Project Background

Before diving into the design patterns, let's create some context about the project where these patterns were implemented. The project started as an idea for automating a hardware troubleshooting workflow in my first role as a software engineer. The automation's workflow can be broken down into 3 high-level steps:

1. **Gather Data**: The automation begins by gathering data from the **ServiceNow API** on hardware incidents submitted by users. These users are distributed all across North America (in the USA and Canada). Each incident includes information on the user's geographic location as well as the specific hardware affected by or causing the incident. For example, an incident could be submitted by a user in Seattle, WA for their malfunctioning credit card reader. Next, the automation queries Splunk - leveraging the **Splunk REST API** - to create a "snapshot" of the device's health over the past 7 days, using the data pulled from Splunk.
2. **Analyze**: The device snapshot(s) are analyzed to diagnose the device; our program needs to try to figure out what's wrong with the device so it can try to do something about it. To fulfill this requirement, we worked with our customer to figure out what data in the device snapshot indicates various anomalous conditions and how to respond. During this step, analysis basically involved iterating over these possible anomalous conditions and finding a match.
3. **Take Action**: With analysis complete, our automation would execute some action intended to remedy the device. The specific action to take is entirely dependent on the diagnosis of the device in the previous step, so while we aren't yet sure what action will be taken, we know we will be _doing something_.
   - Note: the automation may not be able to pinpoint any issue with the device, due to it being limited to a) the data sourced from Splunk and b) the hard-coded conditions for which it is programmed to look for in the device snapshot(s). Even in these cases, the automation always takes some action, such as providing data in the incident work notes.

## Problems

During initial development, we weren't thinking about optimal design patterns; even the above high-level steps weren't yet apparent to us. An important design philosophy (attributed to software engineer Kent Beck) perfectly summarizes the situation we found ourselves in: **"Make it work, make it right, make it fast."** Business requirements - such as deadlines - come with the territory of writing software for business purposes. Our priority was to get something functional in production for our stakeholders (make it work), not making it perfect the first time.

As we expanded the automation's capabilities, several code smells quickly became apparent:

- Too many responsibilities in one place leading to tightly coupled logic. When I say, "too many responsibilities", I mean that a single method - comprised of several hundred lines of code - was responsible for: creating the device snapshots from the Splunk query results, analyzing the snapshot results, taking action (whatever action that may be).

- **Large if-else chains, hard to reason about the codebase.** This was particularly apparent in the 2nd step (Analyze) when the program would attempt to diagnose the device, looping through a set of complex conditions applied to the device snapshot data. Here and elsewhere throughout the codebase, as features were added, readability was reduced.

- **Difficult to test the code.** When trying to test a function/method that is doing too much, you have to make lots of assertions in each test and write many test cases to account for many different conditions.

We were now at the stage of **making it right**. It was somewhat apparent that we should break our classes and methods down into smaller units, adhering more to the single responsibility principle (SRP). The question was _how_.

## Refactoring

Thinking back to the 3 primary steps the automation's workflow consists of, recall that the program analyzes the snapshot data to determine what action to take. The action we take isn't immediately clear - it entirely depends on the outcome of the analysis step at runtime - but we know we'll be _doing something_.

### Strategy pattern

What if we take _what we do_ (step 3: Take Action) and encapsulate it somehow, such as in a function or class? These objects are analogous to **verbs**, i.e., while eating, running, drinking, and writing are all very different things, they are all _things you do_. The **Strategy design pattern** is a **behavioral** pattern that enables selecting an algorithm at runtime. This is achieved by creating a common interface - let's call it `Strategy`, to be consistent - that different classes implement. Your interface will have at least one method - maybe you call it `execute()` or `do_the_thing()` or `run()` - and all implementing classes implement that method in their own way.

### Factory pattern

The outcome of the analysis (step 2) decides what `Strategy` to use. This decision-making step can be encapsulated into a function called a **factory**. The **Factory design pattern** is a **creational** pattern that defines some interface (usually a class or function) for creating different objects. These objects are typically all subclasses of a superclass or they all implement the same common interface(s). The factory contains all the logic needed to determine which class implementing the `Strategy` interface to create.

We now know how to break our code into smaller, focused units. In the next section, I will provide some code samples to demonstrate using these two patterns in tandem and how they make the code more maintainable and scalable.

## Implementation Example

This section walks through implementing a program that exports different reports, using Python to stay consistent with the language originally used to write the automation software. Input data specifies the format of the report (CSV, JSON, or PDF), whether headers should be included, if the report should be compressed, and the destination of the report (such as Amazon S3 or another storage location).

Note: This example is designed around illustrating the structure of the Strategy and Factory design patterns, how they are implemented, and the benefits they provide. This code does not include any actual business logic for creating, exporting, and sending reports.

You can find and run all the below example code <a href="https://github.com/s-meenaghan7/design-patterns-python-demo" target="_blank">in this GitHub repository</a>.

### 1. Create an abstract base Strategy class

The base Strategy class is a _shared interface_ for other Strategy subclasses to adhere to. Each subclass inherits all properties and methods of it's base class, and must implement any abstract methods defined. Python supports abstract class functionality through the `abc` module.

For this program, we'll name the base class `ExportStrategy`. This class _cannot_ be instantiated directly; it must be extended by another class. The `ExportStrategy` needs a `config: dict` object to be instantiated.

```python
# export_strategy.py

from abc import ABC, abstractmethod

class ExportStrategy(ABC):
    """Defines a report export strategy."""

    def __init__(self, config: dict):
        self.export_format = config.get("format")
        self.include_headers = config.get("include_headers", True)
        self.compressed = config.get("compressed", False)
        self.destination = config.get("destination")

    @abstractmethod
    def run(self):
        """Runs the export strategy's shared logic."""
        log_message_parts = [
            "Exporting report as",
            "compressed" if self.compressed else "uncompressed",
            self.export_format.upper(),
            "to",
            self.destination,
        ]

        print(" ".join(log_message_parts))

        # logic continued in extending classes.
        ...
```

### 2. Create concrete Strategy classes

Next, we'll implement concrete `ExportStrategy` subclasses. These subclasses will contain logic for exporting a report in a given file format, and other details such as compressing the file and sending it somewhere.

- Each subclass implements the `run` method from the `ExportStrategy` base class. They have the option of executing their parent's `run` method (using `super().run()`), but this doesn't happen automatically unless specified.
- Remember: in lieu of real business logic, these examples use `print` statements for brevity and focusing on the patterns.

```python
# export_strategy.py

class CsvExportStrategy(ExportStrategy):
    """Defines the CSV export strategy."""

    def run(self):
        """Runs the CSV export strategy."""
        super().run()
        print("Successfully exported CSV report!")
        ...


class JsonExportStrategy(ExportStrategy):
    """Defines the JSON export strategy."""

    def run(self):
        """Runs the JSON export strategy."""
        super().run()
        print("Successfully exported JSON report!")
        ...


class PdfExportStrategy(ExportStrategy):
    """Defines the PDF export strategy."""

    def run(self):
        """Runs the PDF export strategy."""
        super().run()
        print("Successfully exported PDF report!")
        ...
```

### 3. Create a Strategy Factory

Thus far, we have defined our strategies. These classes define and encapsulate _what we do_. We'll now create a factory function that returns an `ExportStrategy` subclass corresponding to some input data and conditional logic around it.

In this example, the factory will simply select the `ExportStrategy` based on the `format` property of the `config` dict. A real report exporting application - or another application, like the workflow automation I described earlier - may need much more complex logic to select the applicable strategy.

```python
# export_strategy.py

def make_export_strategy(config: dict) -> ExportStrategy:
    """Factory function to create ExportStrategy objects from an export configuration."""
    format_map = {
        "csv": CsvExportStrategy,
        "json": JsonExportStrategy,
        "pdf": PdfExportStrategy,
    }
    strategy_class: ExportStrategy = format_map.get(config.get("format").lower())
    if not strategy_class:
        raise ValueError(f"Unsupported export format: {config.get('format')}")

    return strategy_class(config)
```

### 4. Write main application code

We can now put our patterns to use in the main application code. Here, we will hardcode the report configuration, which is provided to the factory function to select our strategy. Finally, we run the selected strategy.

```python
# main.py

from export_strategy import make_export_strategy

export_config = {
    "format": "csv",        # csv | json | pdf
    "include_headers": True,
    "compressed": False,
    "destination": "s3",
}

strategy = make_export_strategy(export_config)

strategy.run()
```

## Results and impacts/benefits

The overarching benefit of implementing these design patterns is to **help complex code adhere to the Single Responsibility Principle** - by separating the logic for **deciding what to do** (into a factory) from the **action(s) being executed** (into separate classes).

Used together or separately\*, applications benefitting from implementing these strategies will have:

- promoted maintainability - classes and functions with single responsibilities are easier to test in isolation.
- promoted scalability - implementing additional strategies is trivial and does not require changing the main application code in `main.py`. For this application, adding a new report exporting strategy is as easy as:
  1. defining the new `ExportStrategy` subclass to implement the specific business logic.
  2. adding logic to the `make_export_strategy` factory function so it can return the new subclass according to the `config` data passed to it.

## Conclusion

Using the Strategy and Factory design patterns, I successfully refactored my team's workflow automation service. The features and functionality of the system did not change, but future maintainance and feature implementation efforts were made substantially easier. While this example code is extremely simplified, a real production system may have much more complex logic implemented in the factory and individual strategies. That is where the pattern's benefits really shine.

These patterns are highly applicable to "rule-based" systems (or parts of a larger system) that:

1. decide on some action to take (based on some complex or large input data), and
2. execute some action

Thank you for reading!

---

### Final remarks

<details>
<summary>Implementation Differences</summary>

Implementation of design patterns can very greatly from language to language. My hope is that my implementation example illustrates the pattern itself in a way that can be translated to other languages. Note that program structure may also vary (i.e., Java enforces having exactly 1 class per file, but in Python, there is no such enforcement, and it may even be considered more "Pythonic" to group inter-related classes into the same module as I do with the `export_strategies.py` module).

</details>

<details>
<summary>Abstract classes in Python</summary>

In Python, we use the `abc` module to implement abstract classes, but it works differently than how other languages implement abstract class functionality:
- If a subclass extending an ABC fails to implement an abstract method/property of the ABC, this will cause a **runtime** error.
- This is in contrast to languages that directly support abstract classes, usually using the `abstract` keyword.
- For these languages, like Java or TypeScript, a **compile-time** error will dictate that subclasses must implement all abstract methods of the base class.

</details>

<details>
<summary>Python ABC vs. duck-typing</summary>

Technically, `abc` is not required in Python to implement the Strategy design pattern through and "abstract" class. This is due to Python's **duck-typing** features. Rather than having an abstract base class (ABC) that other subclasses extend from explicitly, you can be sure that objects are all treated the same **as long as they adhere to the same interface**. In other words:
- each class need only implement the same methods and properties of the "base class" to be treated as that base class.

Personally, I prefer to explicitly use the `abc` module. It provides readers with context into the class's usage and introduces the runtime errors I previously mentioned. `abc` also has other features that you may want to take advantage of, but are beyond the scope of my example here.

</details>
